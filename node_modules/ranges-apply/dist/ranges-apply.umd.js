/**
 * @name ranges-apply
 * @fileoverview Take an array of string index ranges, delete/replace the string according to them
 * @version 7.0.3
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-apply/}
 */

"use strict";var rangesApply=(()=>{var c=Object.defineProperty;var _=Object.getOwnPropertyDescriptor;var N=Object.getOwnPropertyNames,w=Object.getOwnPropertySymbols;var v=Object.prototype.hasOwnProperty,R=Object.prototype.propertyIsEnumerable;var T=(s,t,o)=>t in s?c(s,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):s[t]=o,y=(s,t)=>{for(var o in t||(t={}))v.call(t,o)&&T(s,o,t[o]);if(w)for(var o of w(t))R.call(t,o)&&T(s,o,t[o]);return s};var j=(s,t)=>{for(var o in t)c(s,o,{get:t[o],enumerable:!0})},D=(s,t,o,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let l of N(t))!v.call(s,l)&&l!==o&&c(s,l,{get:()=>t[l],enumerable:!(n=_(t,l))||n.enumerable});return s};var A=s=>D(c({},"__esModule",{value:!0}),s);var F={};j(F,{rApply:()=>M,version:()=>W});var S={strictlyTwoElementsInRangeArrays:!1,progressFn:null};function d(s,t){if(!Array.isArray(s)||!s.length)return s;let o=y(y({},S),t),n,l;if(o.strictlyTwoElementsInRangeArrays&&!s.every((a,p)=>!Array.isArray(a)||a.length!==2?(n=p,l=a.length,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ${n}th range (${JSON.stringify(s[n],null,4)}) has not two but ${l} elements!`);if(!s.every((a,p)=>!Array.isArray(a)||!Number.isInteger(a[0])||a[0]<0||!Number.isInteger(a[1])||a[1]<0?(n=p,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ${n}th range (${JSON.stringify(s[n],null,4)}) does not consist of only natural numbers!`);let r=s.length**2,u=0;return Array.from(s).sort((a,p)=>(o.progressFn&&(u+=1,o.progressFn(Math.floor(u*100/r))),a[0]===p[0]?a[1]<p[1]?-1:a[1]>p[1]?1:0:a[0]<p[0]?-1:1))}var b={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};function $(s,t){function o(e){return!!e&&typeof e=="object"&&!Array.isArray(e)}if(!Array.isArray(s)||!s.length)return null;let n;if(t)if(o(t)){if(n=y(y({},b),t),n.progressFn&&o(n.progressFn)&&!Object.keys(n.progressFn).length)n.progressFn=null;else if(n.progressFn&&typeof n.progressFn!="function")throw new Error(`ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: "${typeof n.progressFn}", equal to ${JSON.stringify(n.progressFn,null,4)}`);if(![1,2,"1","2"].includes(n.mergeType))throw new Error(`ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof n.mergeType}", equal to ${JSON.stringify(n.mergeType,null,4)}`);if(typeof n.joinRangesThatTouchEdges!="boolean")throw new Error(`ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "${typeof n.joinRangesThatTouchEdges}", equal to ${JSON.stringify(n.joinRangesThatTouchEdges,null,4)}`)}else throw new Error(`emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:
${JSON.stringify(t,null,4)} (type ${typeof t})`);else n=y({},b);let l=s.filter(e=>Array.isArray(e)).map(e=>[...e]).filter(e=>e[2]!==void 0||e[0]!==e[1]),r,u,a;n.progressFn?r=d(l,{progressFn:e=>{a=Math.floor(e/5),a!==u&&(u=a,n.progressFn(a))}}):r=d(l);let p=r.length-1;for(let e=p;e>0;e--)n.progressFn&&(a=Math.floor((1-e/p)*78)+21,a!==u&&a>u&&(u=a,n.progressFn(a))),(r[e][0]<=r[e-1][0]||!n.joinRangesThatTouchEdges&&r[e][0]<r[e-1][1]||n.joinRangesThatTouchEdges&&r[e][0]<=r[e-1][1])&&(r[e-1][0]=Math.min(r[e][0],r[e-1][0]),r[e-1][1]=Math.max(r[e][1],r[e-1][1]),r[e][2]!==void 0&&(r[e-1][0]>=r[e][0]||r[e-1][1]<=r[e][1])&&r[e-1][2]!==null&&(r[e][2]===null&&r[e-1][2]!==null?r[e-1][2]=null:r[e-1][2]!=null?+n.mergeType==2&&r[e-1][0]===r[e][0]?r[e-1][2]=r[e][2]:r[e-1][2]+=r[e][2]:r[e-1][2]=r[e][2]),r.splice(e,1),e=r.length);return r.length?r:null}var H=!0,h="Invariant failed";function I(s,t){if(!s){if(H)throw new Error(h);var o=typeof t=="function"?t():t,n=o?"".concat(h,": ").concat(o):h;throw new Error(n)}}var E="7.0.3";var W=E;function M(s,t,o){let n=0,l=0;if(arguments.length===0)throw new Error("ranges-apply: [THROW_ID_01] inputs missing!");if(typeof s!="string")throw new TypeError(`ranges-apply: [THROW_ID_02] first input argument must be a string! Currently it's: ${typeof s}, equal to: ${JSON.stringify(s,null,4)}`);if(t&&!Array.isArray(t))throw new TypeError(`ranges-apply: [THROW_ID_03] second input argument must be an array (or null)! Currently it's: ${typeof t}, equal to: ${JSON.stringify(t,null,4)}`);if(o&&typeof o!="function")throw new TypeError(`ranges-apply: [THROW_ID_04] the third input argument must be a function (or falsey)! Currently it's: ${typeof o}, equal to: ${JSON.stringify(o,null,4)}`);if(!t||!t.filter(i=>i).length)return s;let r;Array.isArray(t)&&Number.isInteger(t[0])&&Number.isInteger(t[1])?r=[Array.from(t)]:r=Array.from(t);let u=r.length,a=0;r.filter(i=>i).forEach((i,g)=>{if(o&&(n=Math.floor(a/u*10),n!==l&&(l=n,o(n))),!Array.isArray(i))throw new TypeError(`ranges-apply: [THROW_ID_05] ranges array, second input arg., has ${g}th element not an array: ${JSON.stringify(i,null,4)}, which is ${typeof i}`);if(!Number.isInteger(i[0])){if(!Number.isInteger(+i[0])||+i[0]<0)throw new TypeError(`ranges-apply: [THROW_ID_06] ranges array, second input arg. has ${g}th element, array ${JSON.stringify(i,null,0)}. Its first element is not an integer, string index, but ${typeof i[0]}, equal to: ${JSON.stringify(i[0],null,4)}.`);r[g][0]=+r[g][0]}if(!Number.isInteger(i[1])){if(!Number.isInteger(+i[1])||+i[1]<0)throw new TypeError(`ranges-apply: [THROW_ID_07] ranges array, second input arg. has ${g}th element, array ${JSON.stringify(i,null,0)}. Its second element is not an integer, string index, but ${typeof i[1]}, equal to: ${JSON.stringify(i[1],null,4)}.`);r[g][1]=+r[g][1]}a+=1});let p=$(r,{progressFn:i=>{o&&(n=10+Math.floor(i/10),n!==l&&(l=n,o(n)))}});I(p);let e=p.length;if(e>0){let i=s.slice(p[e-1][1]);s=p.reduce((g,q,f,m)=>{o&&(n=20+Math.floor(f/e*80),n!==l&&(l=n,o(n)));let O=f===0?0:m[f-1][1],x=m[f][0];return`${g}${s.slice(O,x)}${m[f][2]||""}`},""),s+=i}return s}return A(F);})();
/**
 * @name ranges-sort
 * @fileoverview Sort string index ranges
 * @version 6.0.3
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-sort/}
 */
/**
 * @name ranges-merge
 * @fileoverview Merge and sort string index ranges
 * @version 9.0.3
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-merge/}
 */
